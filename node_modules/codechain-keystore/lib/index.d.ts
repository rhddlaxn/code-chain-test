import { Key, PrivateKey, PublicKey, SecretSeedStorage, SecretStorage, Seed, SeedHash } from "./types";
export { SecretStorage };
export interface KeyStore {
    getKeys(): Promise<Key[]>;
    importRaw(params: {
        privateKey: PrivateKey;
        passphrase?: string;
        meta?: string;
    }): Promise<Key>;
    exportKey(params: {
        key: Key;
        passphrase: string;
    }): Promise<SecretStorage>;
    importKey(params: {
        secret: SecretStorage;
        passphrase: string;
    }): Promise<Key>;
    exportRawKey(params: {
        key: Key;
        passphrase: string;
    }): Promise<PrivateKey>;
    getPublicKey(params: {
        key: Key;
        passphrase: string;
    }): Promise<PublicKey | null>;
    createKey(params: {
        passphrase?: string;
        meta?: string;
    }): Promise<Key>;
    deleteKey(params: {
        key: Key;
    }): Promise<boolean>;
    sign(params: {
        key: Key;
        message: string;
        passphrase: string;
    }): Promise<string>;
    getMeta(params: {
        key: Key;
    }): Promise<string>;
    save(): Promise<SecretStorage[]>;
    load(value: SecretStorage[]): Promise<void>;
    clear(): Promise<void>;
}
export interface HDWKeyStore {
    getSeedHashes(): Promise<SeedHash[]>;
    importSeed(params: {
        secret: SecretSeedStorage;
        passphrase?: string;
    }): Promise<SeedHash>;
    importRawSeed(params: {
        seed: Seed;
        passphrase?: string;
        meta?: string;
    }): Promise<SeedHash>;
    importMnemonic(params: {
        mnemonic: string;
        passphrase?: string;
        meta?: string;
    }): Promise<SeedHash>;
    exportSeed(params: {
        seedHash: SeedHash;
        passphrase: string;
    }): Promise<SecretSeedStorage>;
    exportRawSeed(params: {
        seedHash: SeedHash;
        passphrase: string;
    }): Promise<Seed>;
    exportMnemonic(params: {
        seedHash: SeedHash;
        passphrase: string;
    }): Promise<string>;
    createSeed(params: {
        seedLength?: number;
        passphrase?: string;
        meta?: string;
    }): Promise<SeedHash>;
    deleteSeed(params: {
        seedHash: SeedHash;
    }): Promise<boolean>;
    getPublicKeyFromSeed(params: {
        seedHash: SeedHash;
        path: string;
        passphrase?: string;
    }): Promise<PublicKey>;
    getPrivateKeyFromSeed(params: {
        seedHash: SeedHash;
        path: string;
        passphrase?: string;
    }): Promise<PrivateKey>;
    signFromSeed(params: {
        seedHash: SeedHash;
        path: string;
        message: string;
        passphrase: string;
    }): Promise<string>;
    getMeta(params: {
        seedHash: SeedHash;
    }): Promise<string>;
    save(): Promise<SecretSeedStorage[]>;
    load(value: SecretSeedStorage[]): Promise<void>;
    clear(): Promise<void>;
}
declare class CCKey {
    private context;
    static CCKey: typeof CCKey;
    static create(params?: {
        dbType?: string;
        dbPath?: string;
    }): Promise<CCKey>;
    static exist(params?: {
        dbType?: string;
        dbPath?: string;
    }): Promise<boolean>;
    platform: KeyStore;
    asset: KeyStore;
    hdwseed: HDWKeyStore;
    private constructor();
    getMeta(): Promise<string>;
    setMeta(meta: string): Promise<string>;
    close(): Promise<void>;
    migrate(data: string, params: {
        assetPassphrase: string[];
        platformPassphrase: string[];
    }): Promise<string>;
    save(): Promise<string>;
    load(value: string): Promise<void>;
    clear(): Promise<void>;
}
export { CCKey };
